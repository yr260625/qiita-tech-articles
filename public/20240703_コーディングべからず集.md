---
title: コーディングべからず集
tags:
  - プログラミング
  - 初学者向け
  - クソコード
private: true
updated_at: '2024-07-30T23:26:05+09:00'
id: 1f09c13e1a9b82cbdf2c
organization_url_name: null
slide: false
ignorePublish: false
---
## はじめに

本記事では以下の内容を記載する
* 自分がこれまで見た中で、よくないと感じた設計とコーディングの事例
  * いわゆる「べからず集」としてまとめている
  * サンプルコードは非常に簡略化してぼかしている
  * 対象読者としては、開発にある程度慣れてきた人

## 伝えたいこと

* 最優先に考えるべきは、仕様通りに動くこと
  * 整理しようとしてスケジュールが遅延したり、仕様を満たさなくなったりしたら本末転倒
  * 正しく動いてさえいれば、中身が多少散らかっていても許容範囲としてよい
  * とはいえ、クリーンな状態にしておく方が、保守性の観点からは望ましい
* 現状そのようになった背景を知っておいた方が良い
  * 開発に慣れてくると既存のコードの変な箇所が目に付いてくる
  * それを本当に修正するべきかどうかの検討は必須
    * 何かしらの理由があるのか
    * 開発スケジュール的にどうか
    * 今後の保守が本当に楽になるのか
* 〇〇原則や〇〇パターンについては言及しない
  * 原理原則は確かに重要だが、厳格に守るかどうかは状況次第
    * プロジェクトの目的や納期
    * 使用しているライブラリによる制約
  * 本記事では簡略化のため、それらしき単語をなるべく使わないようにする


## 1. 変数名、関数名に関する事例

### 1-1. ハンガリアン記法

変数名に型のプレフィックスを付ける命名規則

  | 型 | 変数名  |
  | :------: | :---------- |
  | int  | iHoge |
  | char | cHoge |
  | 構造体 | strHoge  |
  | charポインタ | pcHoge |

#### 何がダメか？

* 可読性が悪くなる
  * 型の判断をするなら、IDEを使えば事足りる
  * 変数名に余計な知識が含まれる
* 表記ゆれが多い
  * 例としてint型グローバル定数の場合を考える
  * `g,c,i`の３文字になるわけだが、単純に数えて6通りある
  * `gci,cig,igc,gic,cgi,icg`のいずれか
  * 規約でアルファベット順にするなど
    * たまに意味のある単語が出現する(`cgi`)
    * 構造体や関数ポインタなども考慮するのは中々厳しい

#### どうするべきか？

* 意味のある名前にするだけでよい
* その他細かいスタイルは現場それぞれの規約に従えばよい

```C
int age;
double salary;
char *firstName;
```

#### 余談

* `***List`や`***Array`という命名もハンガリアン記法の一種ではないか？
* 確かに一目で「複数個入る」と認識できるが、稀に誤解を招く場合がある
  * 配列のように見えるが、実はオブジェクトであるとか
  * 名称と実体のずれがあるのは混乱の元なので、なるべく撲滅させたくなる
* 英単語の複数形に則る名称が尤もらしい
  * 日本語の変数名(例：`kaiinBango`)の時にはどうするか
  * その時は妥協して`kaiinBangoList`で
* インターフェースや抽象クラスであることを表すために、`I`や`A`をつけるぐらいなら（個人的には）全然許容できる

### 1-2. スコープが大きく変更可能な変数

手続き型プログラミングでよく見られる、スコープの広い変数の使用

```JavaScript
let someValue = 0;
let someInstance = new Hoge();
// ここから１０００行ぐらい処理
// ~~~~~
// ここまで
return result;
```

#### 何がダメか？

* エラー発生箇所を特定しにくい
* 意図せずに変数の値が変わる
* グローバルスコープの変数に依存する関数は再利用性に欠ける

#### どうするべきか？

* スコープは狭ければ狭いほど良い
* 変数宣言は使用する箇所の直前で行う
* 別目的で使いまわすことはしない
* 広く使用せざるを得ないならば最低限 `readonly` にしておく
* 各言語に応じて不変にするための手段を利用する
  * `final` 宣言（Java）
  * `@dataclass(frozen=True)`（Python）
  * `Object.freeze`（JavaScript）
  * `Proxy` と `Reflect`（JavaScript）

## 2. 共通化に関する事例

### 2-1. 不自然な共通化

以下のようなコードを考える
* パラメーター作成とリクエスト送信を、共通関数`fileManager`で行う
* 処理区分に応じたリクエスト送信を行う
  * 処理区分=1: ファイル追加
  * 処理区分=2: ファイル削除
  * 処理区分=3: フォルダ追加
  * 処理区分=4: フォルダ削除

```javascript
const fileManager = async function (kbn, params) {
  switch (kbn) {
    case 1:
      // ファイル追加用のパラメーター作成
      // POST /file
      break;
    case 2:
      // ファイル削除用のパラメーター作成
      // POST /file
      break;
    case 3:
      // フォルダ追加用のパラメーター作成
      // POST /file
      break;
    case 4:
      // フォルダ削除用のパラメーター作成
      // POST /file
      break;
    default:
      console.log('その他');
  }
}
```

#### 何がダメか？

* `fileManager`という如何にも汎用性がありそうな関数名
* 異なる処理をわざわざまとめておいて、switch文で分岐する意味とは？
* 分岐を呼び出し側で把握しておく必要がある
* 例えば区分=5(リネーム)が追加されるとすると、既存部分と追加部分の両方のテストが必要になる

#### どうするべきか？

* 素直に分割するだけでよい
* 使いまわしが効き、可読性もよくなる
* リクエストパラメーターの生成は、それぞれの関数内で行う
* リクエスト送信は共通化して、あらゆる箇所で使いまわしが効く

```javascript
const addFile = async function (params) {
  // ファイル追加用のパラメーター作成
  // POST /file
}

const removeFile = async function (params) {
  // ファイル削除用のパラメーター作成
  // DELETE /file
}

const addDir = async function (params) {
  // フォルダ追加用のパラメーター作成
  // POST /file
}

const removeDir = async function (params) {
  // フォルダ削除用のパラメーター作成
  // POST /file
}
```

#### 余談

* 全部の種別でエンドポイントが同じにしている
  * あえてRESTfulな設計にするのであればこんな感じ
    `
    ファイル追加: POST /files
    ファイル削除: DELETE /files/{id}
    フォルダ追加: POST /folders
    フォルダ削除: DELETE /folders/{id}
    `
  * バックエンド側の都合上(graphqlなど)そうならざるを得ない場合がある
  * 適切にさばいてくれるなら問題ない

### 2-2. 異なる振る舞いの処理を無理やり共通化

以下のようなコードを考える
* ネットワーク機器にTelnet接続して、コマンド実行結果を整形して呼び元に返却する
* 各Deviceは自身のget_configメソッドを通してTelnet接続し、情報取得を行うものとする
* Telnet接続、切断、コマンド実行を取りまとめる
* `args`に各Deviceの情報が含まれる(ホスト名、IPアドレス、ログインプロンプトなど)

```python
class DeviceService:
  def main(self):
    device_info = Device.get_info()
    session = TelnetSession.open(device_info)
    return session.send(device_info["get_config_command"])

class TelnetSession:
  @staticmethod
  def open(args):
    # 機種ごとにログイン方法が異なるため分岐が発生
    if args['type'] == 1:
      pass
    elif args['type'] == 2:
      pass
    elif args['type'] == 3:
      pass
    else:
      pass
    return

  def send(self, command):
    pass

  def close(self):
    pass
```

#### 何がダメか？

* Telnet接続に関するクラスを**全機種**で使い回すために、以下のようなことが必要になる
  * `open`メソッドで、機種特有の動作を考慮しなくてはならない
  * `args`の全く使用しないキーが多数あることを許容する
  * 機種追加時するたび分岐が増える
* 処理をまとめておいて、実際は分岐している


#### どうするべきか？

* 機種ごとにクラスを分けるほうがまし
  * 既に多くの機種が存在しているなら、修正が困難かつ時間がかかるはず
  * 落としどころとしてはこんな感じ
    * これから追加する機種に関しては、既存の`TelnetSession`は使用禁止
    * 独自の機種クラスを作成する
    * 機種特有の処理はそちらに寄せる
* こういうのはどうか
  * `TelnetSession`のインターフェースを継承したクラスを作る
  * `TelnetSessionFactory`を通じてどの機種のセッションを生成するかを制御する


```python
# サービス
class MainService:
  def main(self):
    # インターフェースを通じてコンフィグ取得
    session_factory = DeviceSessionFactory()
    session = session_factory.create(self.type)
    session.open()
    session.send("get_config_command")
    session.close("get_config_command")

# Telnetセッションの抽象クラス
class ATelnetSession(metaclass=ABCMeta):
  @abstractmethod
  def open(self, args):
    raise NotImplementedError

  @abstractmethod
  def send(self, command):
    raise NotImplementedError

  @abstractmethod
  def close(self):
    raise NotImplementedError

# 機種ごとのTelnetセッションクラス
class Device1Session(ATelnetSession)
  def open(self):
    pass
  def send(self, command):
    pass
  def close(self):
    pass

# セッションファクトリクラスの抽象クラス
class ASessionFactory(metaclass=ABCMeta):
  @abstractmethod
  def create(self, type):
    raise NotImplementedError

# セッションファクトリクラス
class DeviceSessionFactory(ASessionFactory):
    def create(self, type):
        if type == 1:
            return Device1Session()
        elif type == 2:
            return Device2Session()
        else:
            raise ValueError("Invalid type")
```


## 3. コールバックに関する事例

### 3-1. メッセージダイアログの連続表示

以下のようなコードを考える
* `MessageDialog.show`メソッドが既存であるとする
  * 実行するとYes/Noを選択させるダイアログを表示する
  * 引数
    * message: 表示するメッセージ
    * yes: Yes押下時に実行させる関数
    * no: No押下時に実行させる関数
* 上記メソッドを使用して、確認ダイアログを複数回表示する
* 一度でもNoを押すと中断する

```JavaScript
MessageDialog.show({
  message: '処理を開始しますか？',
  yes: () => {
    MessageDialog.show({
      message: '本当にやりますか？',
      yes: () => {
        MessageDialog.show({
          message: '本当の本当にやりますか？',
          yes: () => {
            // 何が何でもやりたい処理
          },
          no: () => {}
        })
      },
      no: () => {}
    })
  },
  no: () => {}
});
```

#### 何がダメか？

* コールバックを連ねることで、ネストが深くなる
  * 見通しが非常に悪い
  * 処理順序が把握しづらい
* 後続の処理を最もネストが深い箇所に書く必要がある
  * そのようにしなければ、Yes/Noをユーザーが選択するのを待たずに処理が進むことになるため

#### どうするべきか？

* メッセージ表示関数を`Promise`でラッピングする
* Yes/Noをユーザーが選択すると、`resolve(true)`または`resolve(false)`で`Promise`を解決する
  * No押下時の処理を早期リターンで実現可能
  * メッセージ追加、削除のいずれも容易
  * 本当に実行させたい処理をメインロジックの一部として実装可能

```JavaScript
// 確認用メッセージ表示関数
const confirm = async (message) => {
  return new Promise((resolve) => {
    MessageDialog.show({
      message,
      yes: () => resolve(true),
      no: () => resolve(false)
    });
  })
}

const main = async () => {
  if (! await confirm('処理を開始しますか？')) {
    return;
  }
  if (! await confirm('本当にやりますか？')) {
    return;
  }
  if (! await confirm('本当の本当にやりますか？')) {
    return;
  }

  // 後続の処理
  doProcess();
}

```

### 3-2. catchされない例外

以下のようなコードを考える

```javascript
// コールバック
function callback(result) {
  console.log("callback");
  throw new Error("Error!");
}
// コールバック呼び出し元
function executeCallback(func) {
  console.log("executeCallback");
  return new Promise(resolve => {
    resolve(true);
  }).then(result => {
    func(result);
  });
}

try {
  executeCallback(callback);
} catch (error) {
  // callbackで発生したエラーをcatchできない
  console.log("catch!");
}
```

#### 何がダメか？

* 大本のtry-catchで捕捉できない
  * `executeCallback`の中で生成したPromiseのcatchメソッドで補足できる
  * 大本で捕捉するには、Promiseのcatchメソッドで更に例外をスローする必要がある
* コールバックが深くなるほどに、catchし損ねる可能性が高まる

#### どうするべきか？

```javascript
// catchメソッドを追加する
executeCallback(callback).catch(error => {
  console.log("catch!", error);
});
```

## 4. 継承に関する事例


## 参考文献

本資料では割愛したが、基本的な原理原則を頭に入れておくことは優れた設計を行うにあたり重要と考える
参考となりそうな書籍や記事を以下に記載する

### 書籍

[良いコード/悪いコードで学ぶ設計入門](https://www.amazon.co.jp/%E8%89%AF%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89-%E6%82%AA%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89%E3%81%A7%E5%AD%A6%E3%81%B6%E8%A8%AD%E8%A8%88%E5%85%A5%E9%96%80-%E2%80%95%E4%BF%9D%E5%AE%88%E3%81%97%E3%82%84%E3%81%99%E3%81%84-%E6%88%90%E9%95%B7%E3%81%97%E7%B6%9A%E3%81%91%E3%82%8B%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E6%9B%B8%E3%81%8D%E6%96%B9-%E4%BB%99%E5%A1%B2/dp/4297127830)

[現場で役立つシステム設計の原則](https://www.amazon.co.jp/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87-%E5%A4%89%E6%9B%B4%E3%82%92%E6%A5%BD%E3%81%A7%E5%AE%89%E5%85%A8%E3%81%AB%E3%81%99%E3%82%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%AE%E5%AE%9F%E8%B7%B5%E6%8A%80%E6%B3%95-%E5%A2%97%E7%94%B0-%E4%BA%A8/dp/477419087X/ref=pd_sbs_d_sccl_3_5/356-9202972-5207621?pd_rd_w=KKY3d&content-id=amzn1.sym.02489f06-7374-46ad-846e-0f2f87544bf3&pf_rd_p=02489f06-7374-46ad-846e-0f2f87544bf3&pf_rd_r=HDZEVHBW2B037P633Q5J&pd_rd_wg=1P4XC&pd_rd_r=e19ef6ad-bb29-4c03-8bff-2de5e48d1d79&pd_rd_i=477419087X&psc=1)

[リーダブルコード](https://www.amazon.co.jp/%E3%83%AA%E3%83%BC%E3%83%80%E3%83%96%E3%83%AB%E3%82%B3%E3%83%BC%E3%83%89-%E2%80%95%E3%82%88%E3%82%8A%E8%89%AF%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B8%E3%81%8F%E3%81%9F%E3%82%81%E3%81%AE%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%A7%E5%AE%9F%E8%B7%B5%E7%9A%84%E3%81%AA%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF-Theory-practice-Boswell/dp/4873115655/ref=pd_vtp_h_pd_vtp_h_d_sccl_1/356-9202972-5207621?pd_rd_w=M8z35&content-id=amzn1.sym.a075abab-259f-40c3-bc0f-76d5f3149ef5&pf_rd_p=a075abab-259f-40c3-bc0f-76d5f3149ef5&pf_rd_r=YMNWE1G48B8QRTQB9JGM&pd_rd_wg=soEhP&pd_rd_r=2ddb6351-8add-4258-96af-394a8703b0ea&pd_rd_i=4873115655&psc=1)

[リファクタリング(第2版)](https://www.amazon.co.jp/%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0-%E7%AC%AC2%E7%89%88-%E6%97%A2%E5%AD%98%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%AE%89%E5%85%A8%E3%81%AB%E6%94%B9%E5%96%84%E3%81%99%E3%82%8B-OBJECT-TECHNOLOGY/dp/4274224546/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=2KLFZPC6VQI1H&dib=eyJ2IjoiMSJ9.8HsAIXWMTxMnfZrcOKDAo9F3d7Ok9OtIN83eGJr0BruAySnNbF23JAfHwjTJXYvLkBs8Ok-cl2kbj365WZ7FTBdgVD0Gd3diusSpnWSAjmN4C4HNRzBYo29-S1J04JQVtXrnwAOVdwd8X4MeWZs_pE40tp2lAGEW5P9dWcQfoxX14A78Eput2iHsmupQBHXVeKQGe6zS4HPNqq8CeY-Ys1yiLFoD5AcZ_3tYkyLOHII.nhY7t2SnX_Ykp-5XXsmzWidD_bF2p5BlAlt_eGCV5U0&dib_tag=se&keywords=%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0&qid=1719808156&s=books&sprefix=%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0%2Cstripbooks%2C199&sr=1-1)


### 記事

[何かのときにすっと出したい、プログラミングに関する法則・原則一覧](https://qiita.com/hirokidaichi/items/d6c473d8011bd9330e63)
[コードを書く際の指針として見返すサイトまとめ](https://qiita.com/kenichi_cc/items/c3ecca7b7d5fc5c6bf2e)
